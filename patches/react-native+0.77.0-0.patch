diff --git a/node_modules/react-native/Libraries/Components/Touchable/TouchableOpacity.d.ts b/node_modules/react-native/Libraries/Components/Touchable/TouchableOpacity.d.ts
index bd72669..e123da8 100644
--- a/node_modules/react-native/Libraries/Components/Touchable/TouchableOpacity.d.ts
+++ b/node_modules/react-native/Libraries/Components/Touchable/TouchableOpacity.d.ts
@@ -53,6 +53,11 @@ export interface TVProps {
    * @platform android
    */
   nextFocusUp?: number | undefined;
+
+  onFocusStyle?: {
+    borderWidth?: number;
+    borderColor?: string;
+  } | undefined;
 }
 
 /**
diff --git a/node_modules/react-native/Libraries/Components/Touchable/TouchableOpacity.js b/node_modules/react-native/Libraries/Components/Touchable/TouchableOpacity.js
index 3fc5e44..9123232 100644
--- a/node_modules/react-native/Libraries/Components/Touchable/TouchableOpacity.js
+++ b/node_modules/react-native/Libraries/Components/Touchable/TouchableOpacity.js
@@ -32,6 +32,10 @@ type TVProps = $ReadOnly<{|
   nextFocusLeft?: ?number,
   nextFocusRight?: ?number,
   nextFocusUp?: ?number,
+  onFocusStyle?: ?{
+    borderWidth?: number,
+    borderColor?: string
+  }
 |}>;
 
 type Props = $ReadOnly<{|
@@ -292,6 +296,7 @@ class TouchableOpacity extends React.Component<Props, State> {
         nextFocusRight={tagForComponentOrHandle(this.props.nextFocusRight)}
         nextFocusUp={tagForComponentOrHandle(this.props.nextFocusUp)}
         hasTVPreferredFocus={this.props.hasTVPreferredFocus === true}
+        onFocusStyle={this.props.onFocusStyle}
         isTVSelectable={
           this.props.isTVSelectable !== false && this.props.accessible !== false
         }
diff --git a/node_modules/react-native/React/Views/RCTTVView.h b/node_modules/react-native/React/Views/RCTTVView.h
index 3d73f92..a0bf16e 100644
--- a/node_modules/react-native/React/Views/RCTTVView.h
+++ b/node_modules/react-native/React/Views/RCTTVView.h
@@ -93,5 +93,6 @@
 - (void)requestTVFocus;
 
 @property (nonatomic, strong) UIFocusGuide * focusGuide;
+@property (nonatomic, copy) NSDictionary *onFocusStyle;
 
 @end
diff --git a/node_modules/react-native/React/Views/RCTTVView.m b/node_modules/react-native/React/Views/RCTTVView.m
index 47d44c7..d6dd27e 100644
--- a/node_modules/react-native/React/Views/RCTTVView.m
+++ b/node_modules/react-native/React/Views/RCTTVView.m
@@ -287,39 +287,77 @@ - (BOOL)shouldUpdateFocusInContext:(UIFocusUpdateContext *)context
   return [super shouldUpdateFocusInContext:context];
 }
 
+//helper method to transform from hex to rgb values
+- (UIColor *)colorFromHexString:(NSString *)hexString {
+    NSLog(@"Converting Hex: %@", hexString); // Debug 1
+    unsigned rgbValue = 0;
+    NSScanner *scanner = [NSScanner scannerWithString:hexString];
+    [scanner setScanLocation:1]; // Skip '#'
+    [scanner scanHexInt:&rgbValue];
+    UIColor *color = [UIColor colorWithRed:((rgbValue & 0xFF0000) >> 16)/255.0 
+                         green:((rgbValue & 0xFF00) >> 8)/255.0 
+                          blue:(rgbValue & 0xFF)/255.0 
+                         alpha:1.0];
+    NSLog(@"Converted to RGB: %@", color); // Debug 2
+    return color;
+}
+
 - (void)didUpdateFocusInContext:(UIFocusUpdateContext *)context
        withAnimationCoordinator:(UIFocusAnimationCoordinator *)coordinator
 {
-  if (context.previouslyFocusedView == context.nextFocusedView) {
-    return;
-  }
+    if (context.previouslyFocusedView == context.nextFocusedView) {
+        return;
+    }
     
-  if (_autoFocus && self.focusGuide != nil && context.previouslyFocusedItem != nil) {
-    // Whenever focus leaves the container, `nextFocusedView` is the destination, the item outside the container.
-    // So, `previouslyFocusedItem` is always the last focused child of `TVFocusGuide`.
-    // We should update `preferredFocusEnvironments` in this case to make sure `FocusGuide` remembers
-    // the last focused element and redirects the focus to it whenever focus comes back.
-    previouslyFocusedItem = context.previouslyFocusedItem;
-    [self handleFocusGuide];
-  }
+    if (_autoFocus && self.focusGuide != nil && context.previouslyFocusedItem != nil) {
+        previouslyFocusedItem = context.previouslyFocusedItem;
+        [self handleFocusGuide];
+    }
     
-  if (context.nextFocusedView == self && ![self isTVFocusGuide] && self.isTVSelectable ) {
-    if (self.onFocus) self.onFocus(nil);
-    [self becomeFirstResponder];
-    [self enableDirectionalFocusGuides];
-    [coordinator addCoordinatedAnimations:^(void){
-      [self addParallaxMotionEffects];
-      [self sendFocusNotification:context];
-    } completion:^(void){}];
-  } else {
-    if (self.onBlur) self.onBlur(nil);
-    [self disableDirectionalFocusGuides];
-    [coordinator addCoordinatedAnimations:^(void){
-      [self sendBlurNotification:context];
-      [self removeParallaxMotionEffects];
-    } completion:^(void){}];
-    [self resignFirstResponder];
-  }
+    if (context.nextFocusedView == self && ![self isTVFocusGuide] && self.isTVSelectable) {
+        NSLog(@"Applying Focus Style: %@", self.onFocusStyle); // Debug 3
+        if (self.onFocus) self.onFocus(nil);
+        [self becomeFirstResponder];
+        [self enableDirectionalFocusGuides];
+        
+        [coordinator addCoordinatedAnimations:^{
+            [self addParallaxMotionEffects];
+            [self sendFocusNotification:context];
+            
+            // Focus style handler
+            if (self.onFocusStyle) {
+                // Handle border width
+                CGFloat borderWidth = [self.onFocusStyle[@"borderWidth"] floatValue];
+                if (!isnan(borderWidth)) {
+                    self.layer.borderWidth = borderWidth;
+                }
+                
+                // Handle border color
+                NSString *borderColor = self.onFocusStyle[@"borderColor"];
+                if ([borderColor isKindOfClass:[NSString class]]) {
+                    self.layer.borderColor = [self colorFromHexString:borderColor].CGColor;
+                }
+                NSLog(@"Border Width: %f, Color: %@", borderWidth, borderColor); // Debug 4
+                // Maintain existing corner radius
+                self.layer.cornerRadius = self.layer.cornerRadius;
+            }
+        } completion:nil];
+    } else {
+        if (self.onBlur) self.onBlur(nil);
+        [self disableDirectionalFocusGuides];
+        
+        [coordinator addCoordinatedAnimations:^{
+            [self sendBlurNotification:context];
+            [self removeParallaxMotionEffects];
+            
+            // CLEAR FOCUS STYLES WHEN LOSING FOCUS
+            if (self.onFocusStyle) {
+                self.layer.borderWidth = 0;
+            }
+        } completion:nil];
+        
+        [self resignFirstResponder];
+    }
 }
 
 // In tvOS, to support directional focus APIs, we add a UIFocusGuide for each
diff --git a/node_modules/react-native/React/Views/RCTViewManager.m b/node_modules/react-native/React/Views/RCTViewManager.m
index 6faafee..66f680d 100644
--- a/node_modules/react-native/React/Views/RCTViewManager.m
+++ b/node_modules/react-native/React/Views/RCTViewManager.m
@@ -185,6 +185,7 @@ - (RCTShadowView *)shadowView
 
 #if TARGET_OS_TV
 // TODO: Delete props for Apple TV.
+RCT_EXPORT_VIEW_PROPERTY(onFocusStyle, NSDictionary)
 RCT_EXPORT_VIEW_PROPERTY(isTVSelectable, BOOL)
 RCT_EXPORT_VIEW_PROPERTY(hasTVPreferredFocus, BOOL)
 RCT_EXPORT_VIEW_PROPERTY(tvParallaxProperties, NSDictionary)
